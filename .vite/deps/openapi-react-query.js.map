{
  "version": 3,
  "sources": ["../../node_modules/openapi-react-query/src/index.ts"],
  "sourcesContent": ["import {\n  type UseMutationOptions,\n  type UseMutationResult,\n  type UseQueryOptions,\n  type UseQueryResult,\n  type InfiniteData,\n  type UseInfiniteQueryOptions,\n  type UseInfiniteQueryResult,\n  type UseSuspenseQueryOptions,\n  type UseSuspenseQueryResult,\n  type QueryClient,\n  type QueryFunctionContext,\n  type SkipToken,\n  useMutation,\n  useQuery,\n  useSuspenseQuery,\n  useInfiniteQuery,\n} from \"@tanstack/react-query\";\nimport type {\n  ClientMethod,\n  FetchResponse,\n  MaybeOptionalInit,\n  Client as FetchClient,\n  DefaultParamsOption,\n} from \"openapi-fetch\";\nimport type { HttpMethod, MediaType, PathsWithMethod, RequiredKeysOf } from \"openapi-typescript-helpers\";\n\n// Helper type to dynamically infer the type from the `select` property\ntype InferSelectReturnType<TData, TSelect> = TSelect extends (data: TData) => infer R ? R : TData;\n\ntype InitWithUnknowns<Init> = Init & { [key: string]: unknown };\n\nexport type QueryKey<\n  Paths extends Record<string, Record<HttpMethod, {}>>,\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init = MaybeOptionalInit<Paths[Path], Method>,\n> = Init extends undefined ? readonly [Method, Path] : readonly [Method, Path, Init];\n\nexport type QueryOptionsFunction<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  path: Path,\n  ...[init, options]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?]\n    : [InitWithUnknowns<Init>, Options?]\n) => NoInfer<\n  Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryFn\"\n  > & {\n    queryFn: Exclude<\n      UseQueryOptions<\n        Response[\"data\"],\n        Response[\"error\"],\n        InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n        QueryKey<Paths, Method, Path>\n      >[\"queryFn\"],\n      SkipToken | undefined\n    >;\n  }\n>;\n\nexport type UseQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  url: Path,\n  ...[init, options, queryClient]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?, QueryClient?]\n    : [InitWithUnknowns<Init>, Options?, QueryClient?]\n) => UseQueryResult<InferSelectReturnType<Response[\"data\"], Options[\"select\"]>, Response[\"error\"]>;\n\nexport type UseInfiniteQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>,\n  Options extends Omit<\n    UseInfiniteQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<InfiniteData<Response[\"data\"]>, Options[\"select\"]>,\n      Response[\"data\"],\n      QueryKey<Paths, Method, Path>,\n      unknown\n    >,\n    \"queryKey\" | \"queryFn\"\n  > & {\n    pageParamName?: string;\n  },\n>(\n  method: Method,\n  url: Path,\n  init: InitWithUnknowns<Init>,\n  options: Options,\n  queryClient?: QueryClient,\n) => UseInfiniteQueryResult<\n  InferSelectReturnType<InfiniteData<Response[\"data\"]>, Options[\"select\"]>,\n  Response[\"error\"]\n>;\n\nexport type UseSuspenseQueryMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<\n    UseSuspenseQueryOptions<\n      Response[\"data\"],\n      Response[\"error\"],\n      InferSelectReturnType<Response[\"data\"], Options[\"select\"]>,\n      QueryKey<Paths, Method, Path>\n    >,\n    \"queryKey\" | \"queryFn\"\n  >,\n>(\n  method: Method,\n  url: Path,\n  ...[init, options, queryClient]: RequiredKeysOf<Init> extends never\n    ? [InitWithUnknowns<Init>?, Options?, QueryClient?]\n    : [InitWithUnknowns<Init>, Options?, QueryClient?]\n) => UseSuspenseQueryResult<InferSelectReturnType<Response[\"data\"], Options[\"select\"]>, Response[\"error\"]>;\n\nexport type UseMutationMethod<Paths extends Record<string, Record<HttpMethod, {}>>, Media extends MediaType> = <\n  Method extends HttpMethod,\n  Path extends PathsWithMethod<Paths, Method>,\n  Init extends MaybeOptionalInit<Paths[Path], Method>,\n  Response extends Required<FetchResponse<Paths[Path][Method], Init, Media>>, // note: Required is used to avoid repeating NonNullable in UseQuery types\n  Options extends Omit<UseMutationOptions<Response[\"data\"], Response[\"error\"], Init>, \"mutationKey\" | \"mutationFn\">,\n>(\n  method: Method,\n  url: Path,\n  options?: Options,\n  queryClient?: QueryClient,\n) => UseMutationResult<Response[\"data\"], Response[\"error\"], Init>;\n\nexport interface OpenapiQueryClient<Paths extends {}, Media extends MediaType = MediaType> {\n  queryOptions: QueryOptionsFunction<Paths, Media>;\n  useQuery: UseQueryMethod<Paths, Media>;\n  useSuspenseQuery: UseSuspenseQueryMethod<Paths, Media>;\n  useInfiniteQuery: UseInfiniteQueryMethod<Paths, Media>;\n  useMutation: UseMutationMethod<Paths, Media>;\n}\n\nexport type MethodResponse<\n  CreatedClient extends OpenapiQueryClient<any, any>,\n  Method extends HttpMethod,\n  Path extends CreatedClient extends OpenapiQueryClient<infer Paths, infer _Media>\n    ? PathsWithMethod<Paths, Method>\n    : never,\n  Options = object,\n> = CreatedClient extends OpenapiQueryClient<infer Paths extends { [key: string]: any }, infer Media extends MediaType>\n  ? NonNullable<FetchResponse<Paths[Path][Method], Options, Media>[\"data\"]>\n  : never;\n\n// TODO: Add the ability to bring queryClient as argument\nexport default function createClient<Paths extends {}, Media extends MediaType = MediaType>(\n  client: FetchClient<Paths, Media>,\n): OpenapiQueryClient<Paths, Media> {\n  const queryFn = async <Method extends HttpMethod, Path extends PathsWithMethod<Paths, Method>>({\n    queryKey: [method, path, init],\n    signal,\n  }: QueryFunctionContext<QueryKey<Paths, Method, Path>>) => {\n    const mth = method.toUpperCase() as Uppercase<typeof method>;\n    const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n    const { data, error, response } = await fn(path, { signal, ...(init as any) }); // TODO: find a way to avoid as any\n    if (error) {\n      throw error;\n    }\n    if (response.status === 204 || response.headers.get(\"Content-Length\") === \"0\") {\n      return data ?? null;\n    }\n\n    return data;\n  };\n\n  const queryOptions: QueryOptionsFunction<Paths, Media> = (method, path, ...[init, options]) => ({\n    queryKey: (init === undefined ? ([method, path] as const) : ([method, path, init] as const)) as QueryKey<\n      Paths,\n      typeof method,\n      typeof path\n    >,\n    queryFn,\n    ...options,\n  });\n\n  return {\n    queryOptions,\n    useQuery: (method, path, ...[init, options, queryClient]) =>\n      useQuery(queryOptions(method, path, init as InitWithUnknowns<typeof init>, options), queryClient),\n    useSuspenseQuery: (method, path, ...[init, options, queryClient]) =>\n      useSuspenseQuery(queryOptions(method, path, init as InitWithUnknowns<typeof init>, options), queryClient),\n    useInfiniteQuery: (method, path, init, options, queryClient) => {\n      const { pageParamName = \"cursor\", ...restOptions } = options;\n      const { queryKey } = queryOptions(method, path, init);\n      return useInfiniteQuery(\n        {\n          queryKey,\n          queryFn: async ({ queryKey: [method, path, init], pageParam = 0, signal }) => {\n            const mth = method.toUpperCase() as Uppercase<typeof method>;\n            const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n            const mergedInit = {\n              ...init,\n              signal,\n              params: {\n                ...(init?.params || {}),\n                query: {\n                  ...(init?.params as { query?: DefaultParamsOption })?.query,\n                  [pageParamName]: pageParam,\n                },\n              },\n            };\n\n            const { data, error } = await fn(path, mergedInit as any);\n            if (error) {\n              throw error;\n            }\n            return data;\n          },\n          ...restOptions,\n        },\n        queryClient,\n      );\n    },\n    useMutation: (method, path, options, queryClient) =>\n      useMutation(\n        {\n          mutationKey: [method, path],\n          mutationFn: async (init) => {\n            const mth = method.toUpperCase() as Uppercase<typeof method>;\n            const fn = client[mth] as ClientMethod<Paths, typeof method, Media>;\n            const { data, error } = await fn(path, init as InitWithUnknowns<typeof init>);\n            if (error) {\n              throw error;\n            }\n\n            return data as Exclude<typeof data, undefined>;\n          },\n          ...options,\n        },\n        queryClient,\n      ),\n  };\n}\n"],
  "mappings": ";;;;;;;;;;;AA2LA,SAAwB,aACtB,QACkC;AAClC,QAAM,UAAU,OAA+E;IAC7F,UAAU,CAAC,QAAQ,MAAM,IAAI;IAC7B;EAAA,MACyD;AACnD,UAAA,MAAM,OAAO,YAAY;AACzB,UAAA,KAAK,OAAO,GAAG;AACrB,UAAM,EAAE,MAAM,OAAO,SAAA,IAAa,MAAM,GAAG,MAAM,EAAE,QAAQ,GAAI,KAAA,CAAc;AAC7E,QAAI,OAAO;AACH,YAAA;IAAA;AAEJ,QAAA,SAAS,WAAW,OAAO,SAAS,QAAQ,IAAI,gBAAgB,MAAM,KAAK;AAC7E,aAAO,QAAQ;IAAA;AAGV,WAAA;EAAA;AAGT,QAAM,eAAmD,CAAC,QAAQ,SAAS,CAAC,MAAM,OAAO,OAAO;IAC9F,UAAW,SAAS,SAAa,CAAC,QAAQ,IAAI,IAAe,CAAC,QAAQ,MAAM,IAAI;IAKhF;IACA,GAAG;EAAA;AAGE,SAAA;IACL;IACA,UAAU,CAAC,QAAQ,SAAS,CAAC,MAAM,SAAS,WAAW,MACrD,SAAS,aAAa,QAAQ,MAAM,MAAuC,OAAO,GAAG,WAAW;IAClG,kBAAkB,CAAC,QAAQ,SAAS,CAAC,MAAM,SAAS,WAAW,MAC7D,iBAAiB,aAAa,QAAQ,MAAM,MAAuC,OAAO,GAAG,WAAW;IAC1G,kBAAkB,CAAC,QAAQ,MAAM,MAAM,SAAS,gBAAgB;AAC9D,YAAM,EAAE,gBAAgB,UAAU,GAAG,YAAA,IAAgB;AACrD,YAAM,EAAE,SAAS,IAAI,aAAa,QAAQ,MAAM,IAAI;AAC7C,aAAA;QACL;UACE;UACA,SAAS,OAAO,EAAE,UAAU,CAACA,SAAQC,OAAMC,KAAI,GAAG,YAAY,GAAG,OAAA,MAAa;AACtE,kBAAA,MAAMF,QAAO,YAAY;AACzB,kBAAA,KAAK,OAAO,GAAG;AACrB,kBAAM,aAAa;cACjB,GAAGE;cACH;cACA,QAAQ;gBACN,GAAIA,OAAM,UAAU,CAAA;gBACpB,OAAO;kBACL,GAAIA,OAAM,QAA4C;kBACtD,CAAC,aAAa,GAAG;gBAAA;cACnB;YACF;AAGF,kBAAM,EAAE,MAAM,MAAA,IAAU,MAAM,GAAGD,OAAM,UAAiB;AACxD,gBAAI,OAAO;AACH,oBAAA;YAAA;AAED,mBAAA;UAAA;UAET,GAAG;QAAA;QAEL;MAAA;IACF;IAEF,aAAa,CAAC,QAAQ,MAAM,SAAS,gBACnC;MACE;QACE,aAAa,CAAC,QAAQ,IAAI;QAC1B,YAAY,OAAO,SAAS;AACpB,gBAAA,MAAM,OAAO,YAAY;AACzB,gBAAA,KAAK,OAAO,GAAG;AACrB,gBAAM,EAAE,MAAM,MAAA,IAAU,MAAM,GAAG,MAAM,IAAqC;AAC5E,cAAI,OAAO;AACH,kBAAA;UAAA;AAGD,iBAAA;QAAA;QAET,GAAG;MAAA;MAEL;IAAA;EACF;AAEN;",
  "names": ["method", "path", "init"]
}
